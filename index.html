<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TRC² — Thalamically Routed Cortical Columns</title>
<link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=DM+Mono:wght@300;400;500&family=Space+Grotesk:wght@300;400;500;600;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
<style>
/* ═══════════════════════════════════════════════════
   CSS CUSTOM PROPERTIES — THEME SYSTEM
   ═══════════════════════════════════════════════════ */
:root {
  --font-display: 'Instrument Serif', Georgia, serif;
  --font-body: 'Space Grotesk', system-ui, sans-serif;
  --font-mono: 'DM Mono', 'Courier New', monospace;
  --font-accent: 'Playfair Display', Georgia, serif;

  /* Shared accent palette */
  --thalamus: #ff6b35;
  --cortex: #4ecdc4;
  --cerebellum: #45b7d1;
  --hippocampus: #a78bfa;
  --neuromod: #f472b6;
  --predictive: #fbbf24;
  --dendrite: #34d399;
  --glow-thalamus: rgba(255, 107, 53, 0.4);
  --glow-cortex: rgba(78, 205, 196, 0.4);
  --glow-cerebellum: rgba(69, 183, 209, 0.4);

  --transition-speed: 0.5s;
  --easing: cubic-bezier(0.16, 1, 0.3, 1);
}

/* DARK THEME */
[data-theme="dark"] {
  --bg-primary: #0a0a0f;
  --bg-secondary: #12121a;
  --bg-card: #1a1a28;
  --bg-card-hover: #222236;
  --bg-code: #161625;
  --text-primary: #e8e6e3;
  --text-secondary: #9ca3af;
  --text-muted: #6b7280;
  --border-color: rgba(255,255,255,0.06);
  --border-accent: rgba(255,255,255,0.12);
  --shadow-card: 0 4px 60px rgba(0,0,0,0.5);
  --gradient-hero: linear-gradient(160deg, #0a0a0f 0%, #1a0a20 30%, #0a1a2f 60%, #0a0a0f 100%);
  --gradient-section: linear-gradient(180deg, transparent, rgba(78,205,196,0.02), transparent);
  --noise-opacity: 0.03;
  --overlay-grid: rgba(255,255,255,0.015);
  --equation-bg: rgba(255,255,255,0.03);
  --table-header: rgba(78,205,196,0.08);
  --table-row-alt: rgba(255,255,255,0.02);
  --particle-color: rgba(255,255,255,0.3);
}

/* LIGHT THEME */
[data-theme="light"] {
  --bg-primary: #faf8f5;
  --bg-secondary: #f0ede8;
  --bg-card: #ffffff;
  --bg-card-hover: #f8f6f3;
  --bg-code: #f5f3ef;
  --text-primary: #1a1a2e;
  --text-secondary: #4a5568;
  --text-muted: #718096;
  --border-color: rgba(0,0,0,0.06);
  --border-accent: rgba(0,0,0,0.12);
  --shadow-card: 0 4px 40px rgba(0,0,0,0.08);
  --gradient-hero: linear-gradient(160deg, #faf8f5 0%, #f0e6f6 30%, #e6f0f8 60%, #faf8f5 100%);
  --gradient-section: linear-gradient(180deg, transparent, rgba(78,205,196,0.04), transparent);
  --noise-opacity: 0.015;
  --overlay-grid: rgba(0,0,0,0.02);
  --equation-bg: rgba(0,0,0,0.03);
  --table-header: rgba(78,205,196,0.1);
  --table-row-alt: rgba(0,0,0,0.02);
  --particle-color: rgba(0,0,0,0.15);
}

/* ═══════════════════════════════════════════════════
   GLOBAL RESET & BASE
   ═══════════════════════════════════════════════════ */
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

html {
  scroll-behavior: smooth;
  font-size: 16px;
  -webkit-font-smoothing: antialiased;
}

body {
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: var(--font-body);
  line-height: 1.7;
  transition: background var(--transition-speed) var(--easing),
              color var(--transition-speed) var(--easing);
  overflow-x: hidden;
}

/* Noise texture overlay */
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='1'/%3E%3C/svg%3E");
  opacity: var(--noise-opacity);
  pointer-events: none;
  z-index: 9999;
}

::selection {
  background: var(--cortex);
  color: #0a0a0f;
}

a { color: var(--cortex); text-decoration: none; }
a:hover { text-decoration: underline; }

/* ═══════════════════════════════════════════════════
   THEME TOGGLE
   ═══════════════════════════════════════════════════ */
.theme-toggle {
  position: fixed;
  top: 24px;
  right: 24px;
  z-index: 1000;
  width: 56px;
  height: 56px;
  border-radius: 50%;
  border: 1px solid var(--border-accent);
  background: var(--bg-card);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.4s var(--easing);
  backdrop-filter: blur(20px);
  box-shadow: var(--shadow-card);
}
.theme-toggle:hover {
  transform: scale(1.1) rotate(15deg);
  border-color: var(--cortex);
}
.theme-toggle svg {
  width: 22px; height: 22px;
  fill: var(--text-primary);
  transition: fill var(--transition-speed);
}
.theme-toggle .sun { display: none; }
[data-theme="light"] .theme-toggle .moon { display: none; }
[data-theme="light"] .theme-toggle .sun { display: block; }

/* ═══════════════════════════════════════════════════
   NAVIGATION
   ═══════════════════════════════════════════════════ */
.nav {
  position: fixed;
  top: 0; left: 0; right: 0;
  z-index: 900;
  padding: 16px 32px;
  display: flex;
  align-items: center;
  gap: 24px;
  background: rgba(10,10,15,0.6);
  backdrop-filter: blur(30px) saturate(1.5);
  border-bottom: 1px solid var(--border-color);
  transform: translateY(-100%);
  transition: transform 0.5s var(--easing), background 0.5s;
}
[data-theme="light"] .nav {
  background: rgba(250,248,245,0.7);
}
.nav.visible { transform: translateY(0); }
.nav-logo {
  font-family: var(--font-display);
  font-size: 1.3rem;
  color: var(--cortex);
  white-space: nowrap;
}
.nav-links {
  display: flex; gap: 20px;
  list-style: none;
  margin-left: auto;
  margin-right: 72px;
}
.nav-links a {
  font-size: 0.82rem;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--text-secondary);
  transition: color 0.3s;
}
.nav-links a:hover { color: var(--cortex); text-decoration: none; }

/* ═══════════════════════════════════════════════════
   LAYOUT
   ═══════════════════════════════════════════════════ */
.container {
  max-width: 900px;
  margin: 0 auto;
  padding: 0 32px;
}
.wide-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 32px;
}

/* ═══════════════════════════════════════════════════
   HERO SECTION
   ═══════════════════════════════════════════════════ */
.hero {
  position: relative;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  background: var(--gradient-hero);
  overflow: hidden;
  padding: 80px 32px;
}

/* Animated neural network canvas */
#neural-canvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  opacity: 0.35;
}

.hero-badge {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 20px;
  border-radius: 100px;
  border: 1px solid var(--border-accent);
  background: var(--bg-card);
  font-family: var(--font-mono);
  font-size: 0.75rem;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--cortex);
  margin-bottom: 40px;
  animation: fadeSlideUp 1s 0.2s var(--easing) both;
}
.hero-badge::before {
  content: '';
  width: 6px; height: 6px;
  border-radius: 50%;
  background: var(--cortex);
  animation: pulse-dot 2s infinite;
}

@keyframes pulse-dot {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.4; transform: scale(0.7); }
}

.hero h1 {
  font-family: var(--font-display);
  font-size: clamp(3.2rem, 8vw, 7rem);
  line-height: 1.05;
  letter-spacing: -0.03em;
  max-width: 900px;
  animation: fadeSlideUp 1s 0.4s var(--easing) both;
}

.hero h1 .accent {
  background: linear-gradient(135deg, var(--thalamus), var(--cortex));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.hero-subtitle {
  font-family: var(--font-accent);
  font-style: italic;
  font-size: clamp(1.1rem, 2.5vw, 1.5rem);
  color: var(--text-secondary);
  max-width: 700px;
  margin-top: 28px;
  animation: fadeSlideUp 1s 0.6s var(--easing) both;
}

.hero-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 24px;
  justify-content: center;
  margin-top: 48px;
  animation: fadeSlideUp 1s 0.8s var(--easing) both;
}

.hero-meta-item {
  font-family: var(--font-mono);
  font-size: 0.78rem;
  color: var(--text-muted);
  letter-spacing: 0.05em;
}
.hero-meta-item strong {
  color: var(--text-primary);
  font-weight: 500;
}

.hero-scroll-hint {
  position: absolute;
  bottom: 40px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  animation: fadeSlideUp 1s 1.2s var(--easing) both;
}
.hero-scroll-hint span {
  font-family: var(--font-mono);
  font-size: 0.65rem;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  color: var(--text-muted);
}
.scroll-line {
  width: 1px; height: 40px;
  background: linear-gradient(to bottom, var(--cortex), transparent);
  animation: scroll-pulse 2s infinite;
}
@keyframes scroll-pulse {
  0% { opacity: 1; transform: scaleY(1); }
  50% { opacity: 0.3; transform: scaleY(0.5); }
  100% { opacity: 1; transform: scaleY(1); }
}

@keyframes fadeSlideUp {
  from { opacity: 0; transform: translateY(40px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ═══════════════════════════════════════════════════
   SECTION STYLING
   ═══════════════════════════════════════════════════ */
section {
  padding: 100px 0;
  position: relative;
}

.section-label {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  letter-spacing: 0.2em;
  text-transform: uppercase;
  color: var(--cortex);
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 12px;
}
.section-label::before {
  content: '';
  width: 32px; height: 1px;
  background: var(--cortex);
}

.section-title {
  font-family: var(--font-display);
  font-size: clamp(2rem, 4vw, 3.2rem);
  line-height: 1.15;
  letter-spacing: -0.02em;
  margin-bottom: 32px;
}

.section-body {
  color: var(--text-secondary);
  font-size: 1.05rem;
  line-height: 1.8;
  max-width: 720px;
}
.section-body p + p {
  margin-top: 20px;
}

/* ═══════════════════════════════════════════════════
   ANIMATED BRAIN COMPONENT CARDS
   ═══════════════════════════════════════════════════ */
.components-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  gap: 24px;
  margin-top: 56px;
}

.comp-card {
  position: relative;
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 20px;
  padding: 36px;
  overflow: hidden;
  transition: all 0.5s var(--easing);
  cursor: default;
}
.comp-card::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 3px;
  background: var(--card-accent, var(--cortex));
  opacity: 0;
  transition: opacity 0.4s;
}
.comp-card:hover::before { opacity: 1; }
.comp-card:hover {
  transform: translateY(-4px);
  border-color: var(--border-accent);
  box-shadow: var(--shadow-card);
}

.comp-icon {
  width: 72px;
  height: 72px;
  margin-bottom: 20px;
  position: relative;
}
.comp-icon svg {
  width: 100%;
  height: 100%;
}

.comp-card h3 {
  font-family: var(--font-display);
  font-size: 1.35rem;
  margin-bottom: 12px;
}
.comp-card p {
  color: var(--text-secondary);
  font-size: 0.92rem;
  line-height: 1.65;
}
.comp-card .comp-tag {
  display: inline-block;
  margin-top: 16px;
  font-family: var(--font-mono);
  font-size: 0.68rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  padding: 4px 12px;
  border-radius: 100px;
  border: 1px solid var(--border-accent);
  color: var(--text-muted);
}

/* ═══════════════════════════════════════════════════
   ARCHITECTURE DIAGRAM SECTION
   ═══════════════════════════════════════════════════ */
.arch-section {
  background: var(--gradient-section);
}

.arch-diagram-wrap {
  position: relative;
  margin: 48px auto;
  max-width: 900px;
}

.arch-flow {
  display: flex;
  flex-direction: column;
  gap: 4px;
  align-items: center;
}

.arch-node {
  position: relative;
  width: 100%;
  max-width: 640px;
  padding: 20px 28px;
  border-radius: 14px;
  border: 1px solid var(--border-color);
  background: var(--bg-card);
  font-size: 0.9rem;
  transition: all 0.4s var(--easing);
  overflow: hidden;
}
.arch-node:hover {
  border-color: var(--node-color, var(--border-accent));
  box-shadow: 0 0 40px rgba(78,205,196,0.08);
  transform: scale(1.01);
}
.arch-node-label {
  font-family: var(--font-mono);
  font-size: 0.68rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 8px;
}
.arch-node-label .dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  display: inline-block;
}
.arch-node-title {
  font-family: var(--font-display);
  font-size: 1.15rem;
  margin-bottom: 4px;
}
.arch-node-desc {
  font-size: 0.82rem;
  color: var(--text-secondary);
  font-family: var(--font-mono);
}

.arch-arrow {
  display: flex;
  flex-direction: column;
  align-items: center;
  height: 36px;
  position: relative;
}
.arch-arrow::before {
  content: '';
  width: 1px; height: 28px;
  background: linear-gradient(to bottom, var(--border-accent), var(--cortex));
  animation: flow-down 2s infinite linear;
}
.arch-arrow::after {
  content: '';
  width: 8px; height: 8px;
  border-right: 1px solid var(--cortex);
  border-bottom: 1px solid var(--cortex);
  transform: rotate(45deg);
  margin-top: -4px;
}
@keyframes flow-down {
  0% { opacity: 0.3; }
  50% { opacity: 1; }
  100% { opacity: 0.3; }
}

/* ═══════════════════════════════════════════════════
   EQUATIONS
   ═══════════════════════════════════════════════════ */
.equation-block {
  background: var(--equation-bg);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 24px 32px;
  margin: 24px 0;
  font-family: var(--font-mono);
  font-size: 0.88rem;
  overflow-x: auto;
  position: relative;
}
.equation-block::before {
  content: attr(data-eq);
  position: absolute;
  right: 16px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 0.72rem;
  color: var(--text-muted);
}

/* ═══════════════════════════════════════════════════
   TABLES
   ═══════════════════════════════════════════════════ */
.results-table-wrap {
  overflow-x: auto;
  margin: 32px 0;
  border-radius: 16px;
  border: 1px solid var(--border-color);
  background: var(--bg-card);
}
.results-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.88rem;
}
.results-table th {
  font-family: var(--font-mono);
  font-size: 0.72rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  text-align: left;
  padding: 16px 20px;
  background: var(--table-header);
  color: var(--text-secondary);
  border-bottom: 1px solid var(--border-color);
  white-space: nowrap;
}
.results-table td {
  padding: 14px 20px;
  border-bottom: 1px solid var(--border-color);
  white-space: nowrap;
}
.results-table tr:nth-child(even) td {
  background: var(--table-row-alt);
}
.results-table .highlight-row td {
  color: var(--cortex);
  font-weight: 600;
}
.results-table .best-val {
  color: var(--cortex);
  font-weight: 600;
}

/* ═══════════════════════════════════════════════════
   ANIMATED BRAIN SVG ICONS
   ═══════════════════════════════════════════════════ */
@keyframes neuron-pulse {
  0%, 100% { r: 3; opacity: 0.8; }
  50% { r: 5; opacity: 1; }
}
@keyframes synapse-fire {
  0% { stroke-dashoffset: 30; opacity: 0.3; }
  50% { stroke-dashoffset: 0; opacity: 1; }
  100% { stroke-dashoffset: -30; opacity: 0.3; }
}
@keyframes rotate-slow {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
@keyframes orbit {
  from { transform: rotate(0deg) translateX(22px) rotate(0deg); }
  to { transform: rotate(360deg) translateX(22px) rotate(-360deg); }
}

.icon-animated circle.pulse {
  animation: neuron-pulse 2s ease-in-out infinite;
}
.icon-animated line.synapse {
  stroke-dasharray: 15;
  animation: synapse-fire 1.5s ease-in-out infinite;
}

/* ═══════════════════════════════════════════════════
   BAR CHART VIS
   ═══════════════════════════════════════════════════ */
.chart-container {
  margin: 40px 0;
  padding: 32px;
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 16px;
}
.chart-title {
  font-family: var(--font-mono);
  font-size: 0.72rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--text-muted);
  margin-bottom: 24px;
}
.chart-bars {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
.chart-bar-row {
  display: flex;
  align-items: center;
  gap: 16px;
}
.chart-bar-label {
  width: 120px;
  font-family: var(--font-mono);
  font-size: 0.78rem;
  text-align: right;
  color: var(--text-secondary);
  flex-shrink: 0;
}
.chart-bar-track {
  flex: 1;
  height: 28px;
  background: var(--equation-bg);
  border-radius: 6px;
  overflow: hidden;
  position: relative;
}
.chart-bar-fill {
  height: 100%;
  border-radius: 6px;
  transition: width 1.5s var(--easing);
  position: relative;
}
.chart-bar-fill::after {
  content: attr(data-val);
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  font-family: var(--font-mono);
  font-size: 0.7rem;
  font-weight: 600;
  color: #0a0a0f;
}
.chart-bar-fill.trc2 { background: linear-gradient(90deg, var(--cortex), var(--thalamus)); }
.chart-bar-fill.transformer { background: linear-gradient(90deg, #6b7280, #9ca3af); }
.chart-bar-fill.mamba { background: linear-gradient(90deg, #4b5563, #6b7280); }

/* ═══════════════════════════════════════════════════
   CONTRIBUTION CARDS
   ═══════════════════════════════════════════════════ */
.contrib-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
  margin-top: 48px;
}
@media (max-width: 768px) {
  .contrib-grid { grid-template-columns: 1fr; }
}
.contrib-card {
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  padding: 32px;
  position: relative;
  transition: all 0.4s var(--easing);
}
.contrib-card:hover {
  transform: translateY(-3px);
  box-shadow: var(--shadow-card);
}
.contrib-num {
  font-family: var(--font-display);
  font-size: 3.5rem;
  line-height: 1;
  background: linear-gradient(135deg, var(--cortex), transparent);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 16px;
  opacity: 0.6;
}
.contrib-card h3 {
  font-family: var(--font-display);
  font-size: 1.15rem;
  margin-bottom: 12px;
}
.contrib-card p {
  font-size: 0.88rem;
  color: var(--text-secondary);
  line-height: 1.6;
}

/* ═══════════════════════════════════════════════════
   FOOTER
   ═══════════════════════════════════════════════════ */
.footer {
  padding: 60px 0;
  text-align: center;
  border-top: 1px solid var(--border-color);
}
.footer p {
  font-family: var(--font-mono);
  font-size: 0.78rem;
  color: var(--text-muted);
}

/* ═══════════════════════════════════════════════════
   SCROLL ANIMATIONS
   ═══════════════════════════════════════════════════ */
.reveal {
  opacity: 0;
  transform: translateY(30px);
  transition: opacity 0.8s var(--easing), transform 0.8s var(--easing);
}
.reveal.visible {
  opacity: 1;
  transform: translateY(0);
}

/* Stagger children */
.stagger-children > * {
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 0.6s var(--easing), transform 0.6s var(--easing);
}
.stagger-children.visible > *:nth-child(1) { transition-delay: 0.0s; opacity: 1; transform: translateY(0); }
.stagger-children.visible > *:nth-child(2) { transition-delay: 0.1s; opacity: 1; transform: translateY(0); }
.stagger-children.visible > *:nth-child(3) { transition-delay: 0.2s; opacity: 1; transform: translateY(0); }
.stagger-children.visible > *:nth-child(4) { transition-delay: 0.3s; opacity: 1; transform: translateY(0); }
.stagger-children.visible > *:nth-child(5) { transition-delay: 0.4s; opacity: 1; transform: translateY(0); }
.stagger-children.visible > *:nth-child(6) { transition-delay: 0.5s; opacity: 1; transform: translateY(0); }
.stagger-children.visible > *:nth-child(7) { transition-delay: 0.6s; opacity: 1; transform: translateY(0); }

/* Dividers */
.section-divider {
  width: 100%;
  max-width: 200px;
  height: 1px;
  margin: 0 auto;
  background: linear-gradient(90deg, transparent, var(--cortex), transparent);
  opacity: 0.3;
}

/* ═══════════════════════════════════════════════════
   RESPONSIVE
   ═══════════════════════════════════════════════════ */
@media (max-width: 640px) {
  .container, .wide-container { padding: 0 20px; }
  section { padding: 60px 0; }
  .nav-links { display: none; }
  .components-grid { grid-template-columns: 1fr; }
}

/* Animated brain background for sections */
.brain-bg {
  position: absolute;
  right: -120px;
  top: 50%;
  transform: translateY(-50%);
  width: 500px;
  height: 500px;
  opacity: 0.03;
  pointer-events: none;
}

/* Citation tooltip */
.cite {
  cursor: help;
  border-bottom: 1px dotted var(--text-muted);
}

/* Special highlight block */
.highlight-block {
  background: linear-gradient(135deg, rgba(78,205,196,0.06), rgba(255,107,53,0.04));
  border-left: 3px solid var(--cortex);
  border-radius: 0 12px 12px 0;
  padding: 24px 28px;
  margin: 28px 0;
  font-size: 1rem;
  color: var(--text-secondary);
  line-height: 1.7;
}
.highlight-block strong {
  color: var(--text-primary);
}

/* Inline code */
code {
  font-family: var(--font-mono);
  font-size: 0.85em;
  background: var(--equation-bg);
  padding: 2px 8px;
  border-radius: 4px;
  border: 1px solid var(--border-color);
}

/* Floating particles */
.particles-container {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: -1;
  overflow: hidden;
}
.particle {
  position: absolute;
  width: 2px; height: 2px;
  background: var(--particle-color);
  border-radius: 50%;
  animation: float-particle linear infinite;
}
@keyframes float-particle {
  0% { transform: translateY(100vh) translateX(0); opacity: 0; }
  10% { opacity: 1; }
  90% { opacity: 1; }
  100% { transform: translateY(-10vh) translateX(40px); opacity: 0; }
}

/* Horizontal rule with brain motif */
.brain-hr {
  margin: 80px auto;
  text-align: center;
  position: relative;
}
.brain-hr::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 0; right: 0;
  height: 1px;
  background: var(--border-color);
}
.brain-hr svg {
  position: relative;
  z-index: 1;
  background: var(--bg-primary);
  padding: 0 20px;
  transition: background var(--transition-speed);
}

/* ═══════════════════════════════════════════════════
   ANIMATED TOKEN FLOW CANVAS
   ═══════════════════════════════════════════════════ */
.token-flow-section {
  padding: 100px 0;
}
.canvas-outer {
  position: relative;
  width: 100%;
  margin-top: 40px;
  border-radius: 24px;
  overflow: hidden;
  border: 1px solid var(--border-accent);
  box-shadow: var(--shadow-card);
}
[data-theme="dark"] .canvas-outer {
  background: linear-gradient(145deg, #0d1a2a 0%, #0a1020 40%, #120a1e 70%, #0a0a14 100%);
}
[data-theme="light"] .canvas-outer {
  background: linear-gradient(145deg, #1a3a5c 0%, #15304e 40%, #2a1848 70%, #1a2040 100%);
}
#tokenFlowCanvas {
  width: 100%;
  height: 820px;
  display: block;
}
.canvas-legend {
  position: absolute;
  bottom: 16px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 18px;
  flex-wrap: wrap;
  justify-content: center;
}
.canvas-legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.68rem;
  color: rgba(255,255,255,0.6);
  font-family: var(--font-mono);
  letter-spacing: 0.04em;
}
.canvas-legend-dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.canvas-controls {
  position: absolute;
  top: 16px;
  right: 16px;
  display: flex;
  gap: 8px;
}
.canvas-controls button {
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.15);
  color: rgba(255,255,255,0.7);
  font-family: var(--font-mono);
  font-size: 0.68rem;
  padding: 6px 14px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s;
  letter-spacing: 0.05em;
  text-transform: uppercase;
}
.canvas-controls button:hover {
  background: rgba(255,255,255,0.15);
  color: #fff;
}
.canvas-controls button.active {
  background: rgba(78,205,196,0.2);
  border-color: rgba(78,205,196,0.4);
  color: #4ecdc4;
}
</style>
</head>
<body>

<!-- Floating particles -->
<div class="particles-container" id="particles"></div>

<!-- Theme toggle -->
<button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
  <svg class="moon" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
  <svg class="sun" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5" fill="none" stroke="currentColor" stroke-width="2"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
</button>

<!-- Navigation -->
<nav class="nav" id="nav">
  <span class="nav-logo">TRC²</span>
  <ul class="nav-links">
    <li><a href="#abstract">Abstract</a></li>
    <li><a href="#components">Architecture</a></li>
    <li><a href="#method">Method</a></li>
    <li><a href="#results">Results</a></li>
    <li><a href="#discussion">Discussion</a></li>
  </ul>
</nav>

<!-- ═══════════════════════════ HERO ═══════════════════════════ -->
<header class="hero">
  <canvas id="neural-canvas"></canvas>

  <div class="hero-badge">arXiv:2602.22479v1 · cs.LG · Feb 2026</div>

  <h1>
    <span class="accent">TRC²</span><br>
    Thalamically Routed<br>Cortical Columns
  </h1>

  <p class="hero-subtitle">
    Efficient Continual Learning in Language Models via<br>
    Biologically Grounded Sparse Routing & Fast Correction
  </p>

  <div class="hero-meta">
    <div class="hero-meta-item"><strong>Afshin Khadangi</strong> · SnT, University of Luxembourg</div>
    <div class="hero-meta-item">Working Paper · 169M params</div>
    <div class="hero-meta-item">~2.88B tokens trained</div>
  </div>

  <div class="hero-scroll-hint">
    <span>Scroll to explore</span>
    <div class="scroll-line"></div>
  </div>
</header>

<!-- ═══════════════════════════ ABSTRACT ═══════════════════════════ -->
<section id="abstract">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Abstract</div>
      <div class="section-body">
        <p>Continual learning is a core requirement for deployed language models, yet standard training pipelines remain brittle under non-stationary data. Online updates often induce <em>catastrophic forgetting</em>, while stability-improving methods frequently increase latency and memory in ways that don't scale.</p>

        <p>We introduce <strong>TRC²</strong> (Thalamically Routed Cortical Columns), a decoder-only backbone that addresses continual learning <em>at the architectural level</em>. TRC² combines sparse thalamic routing over cortical columns with mechanisms for modulation, prediction, memory, and feedback — together with a fast corrective pathway that supports rapid adaptation without destabilizing slower parameters.</p>

        <p>The resulting block is sparse and chunk-parallel, enabling efficient training and inference while preserving clean ablations of each subsystem. Across language modeling and continual learning benchmarks, TRC² improves the stability–plasticity tradeoff at comparable compute.</p>
      </div>
    </div>

    <div class="highlight-block reveal" style="margin-top: 40px;">
      <strong>Core thesis:</strong> Continual learning should be an architectural property, not a bolt-on procedure. Plasticity should be localized in fast mechanisms while slower representational structures remain stable.
    </div>
  </div>
</section>

<div class="section-divider"></div>

<!-- ═══════════════════════════ CONTRIBUTIONS ═══════════════════════════ -->
<section>
  <div class="wide-container">
    <div class="reveal">
      <div class="section-label">Contributions</div>
      <div class="section-title">Three Key Contributions</div>
    </div>

    <div class="contrib-grid stagger-children reveal">
      <div class="contrib-card">
        <div class="contrib-num">01</div>
        <h3>The TRC² Architecture</h3>
        <p>A decoder-only backbone combining sparse thalamic top-k routing over cortical columns with biologically grounded mechanisms for modulation, prediction, memory, feedback, and fast correction.</p>
      </div>
      <div class="contrib-card">
        <div class="contrib-num">02</div>
        <h3>Sparse Chunk-Parallel Implementation</h3>
        <p>Topology-aware routing, chunk-level computation, and memory-aware execution with optional activation checkpointing for efficient training on modern accelerators.</p>
      </div>
      <div class="contrib-card">
        <div class="contrib-num">03</div>
        <h3>Continual Learning Evaluation Stack</h3>
        <p>Distributed multi-GPU training, standardized logging, and task-wise evaluations tracking forgetting and forward transfer under streaming domain shifts.</p>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"></div>

<!-- ═══════════════════════════ BRAIN COMPONENTS ═══════════════════════════ -->
<section id="components">
  <div class="wide-container">
    <div class="reveal">
      <div class="section-label">Architecture</div>
      <div class="section-title">Seven Brain-Inspired Subsystems</div>
      <div class="section-body">
        <p>Each subsystem is independently toggleable and draws from a distinct neuroscience principle. Together they form a looped layer structure that routes, modulates, predicts, remembers, and corrects.</p>
      </div>
    </div>

    <div class="components-grid stagger-children reveal">

      <!-- Card 1: Neuromodulator -->
      <div class="comp-card" style="--card-accent: var(--neuromod);">
        <div class="comp-icon">
          <svg viewBox="0 0 72 72" class="icon-animated">
            <defs>
              <radialGradient id="glow-nm" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="#f472b6" stop-opacity="0.3"/>
                <stop offset="100%" stop-color="#f472b6" stop-opacity="0"/>
              </radialGradient>
            </defs>
            <circle cx="36" cy="36" r="34" fill="url(#glow-nm)"/>
            <!-- Central hub -->
            <circle cx="36" cy="36" r="8" fill="none" stroke="#f472b6" stroke-width="1.5" opacity="0.8"/>
            <circle cx="36" cy="36" r="3" fill="#f472b6" class="pulse"/>
            <!-- Three orbiting signals: D, ACh, NE -->
            <g style="transform-origin: 36px 36px; animation: rotate-slow 8s linear infinite;">
              <circle cx="36" cy="14" r="4" fill="#ff6b35" opacity="0.9"/>
              <text x="36" y="16" text-anchor="middle" fill="#0a0a0f" font-size="5" font-weight="bold" font-family="monospace">D</text>
            </g>
            <g style="transform-origin: 36px 36px; animation: rotate-slow 8s linear infinite reverse;">
              <circle cx="55" cy="48" r="4" fill="#4ecdc4" opacity="0.9"/>
              <text x="55" y="50" text-anchor="middle" fill="#0a0a0f" font-size="4.5" font-weight="bold" font-family="monospace">ACh</text>
            </g>
            <g style="transform-origin: 36px 36px; animation: rotate-slow 12s linear infinite;">
              <circle cx="17" cy="48" r="4" fill="#fbbf24" opacity="0.9"/>
              <text x="17" y="50" text-anchor="middle" fill="#0a0a0f" font-size="4.5" font-weight="bold" font-family="monospace">NE</text>
            </g>
            <!-- Connections -->
            <line x1="36" y1="28" x2="36" y2="18" stroke="#f472b6" stroke-width="0.7" class="synapse" opacity="0.5"/>
            <line x1="42" y1="40" x2="51" y2="46" stroke="#f472b6" stroke-width="0.7" class="synapse" opacity="0.5" style="animation-delay: 0.5s"/>
            <line x1="30" y1="40" x2="21" y2="46" stroke="#f472b6" stroke-width="0.7" class="synapse" opacity="0.5" style="animation-delay: 1s"/>
          </svg>
        </div>
        <h3>Neuromodulator Controller</h3>
        <p>Estimates dopamine, acetylcholine, and norepinephrine signals from running input statistics. Controls routing temperature, top-down/bottom-up balance, and global cortical gain.</p>
        <span class="comp-tag">Modulation</span>
      </div>

      <!-- Card 2: Predictive Cortex -->
      <div class="comp-card" style="--card-accent: var(--predictive);">
        <div class="comp-icon">
          <svg viewBox="0 0 72 72" class="icon-animated">
            <defs>
              <radialGradient id="glow-pc" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="#fbbf24" stop-opacity="0.25"/>
                <stop offset="100%" stop-color="#fbbf24" stop-opacity="0"/>
              </radialGradient>
            </defs>
            <circle cx="36" cy="36" r="34" fill="url(#glow-pc)"/>
            <!-- Prediction wave -->
            <path d="M12 36 Q 20 24, 28 36 T 44 36 T 60 36" fill="none" stroke="#fbbf24" stroke-width="1.5" stroke-dasharray="4 3" opacity="0.6">
              <animate attributeName="stroke-dashoffset" from="0" to="-28" dur="2s" repeatCount="indefinite"/>
            </path>
            <!-- Actual signal -->
            <path d="M12 38 Q 22 28, 30 38 T 48 38 T 60 38" fill="none" stroke="#ff6b35" stroke-width="1.2" opacity="0.8"/>
            <!-- Error arrows -->
            <line x1="28" y1="36" x2="30" y2="38" stroke="#ef4444" stroke-width="1" opacity="0.7">
              <animate attributeName="opacity" values="0.3;1;0.3" dur="1.5s" repeatCount="indefinite"/>
            </line>
            <line x1="44" y1="36" x2="48" y2="38" stroke="#ef4444" stroke-width="1" opacity="0.7">
              <animate attributeName="opacity" values="0.3;1;0.3" dur="1.5s" repeatCount="indefinite" begin="0.5s"/>
            </line>
            <!-- Labels -->
            <text x="12" y="52" fill="var(--text-muted)" font-size="5" font-family="monospace" opacity="0.7">P̂</text>
            <text x="50" y="52" fill="var(--text-muted)" font-size="5" font-family="monospace" opacity="0.7">ε = U − P̂</text>
          </svg>
        </div>
        <h3>Predictive Cortex</h3>
        <p>Implements Rao & Ballard predictive coding. A causal convolution generates prior predictions; the cortex processes prediction errors rather than raw signals. ACh dynamically weights the blend.</p>
        <span class="comp-tag">Prediction</span>
      </div>

      <!-- Card 3: Thalamic Router -->
      <div class="comp-card" style="--card-accent: var(--thalamus);">
        <div class="comp-icon">
          <svg viewBox="0 0 72 72" class="icon-animated">
            <defs>
              <radialGradient id="glow-th" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="#ff6b35" stop-opacity="0.25"/>
                <stop offset="100%" stop-color="#ff6b35" stop-opacity="0"/>
              </radialGradient>
            </defs>
            <circle cx="36" cy="36" r="34" fill="url(#glow-th)"/>
            <!-- Central thalamus -->
            <ellipse cx="36" cy="36" rx="10" ry="7" fill="none" stroke="#ff6b35" stroke-width="1.5" opacity="0.8"/>
            <circle cx="36" cy="36" r="3" fill="#ff6b35" opacity="0.8" class="pulse"/>
            <!-- Cortical columns (targets) -->
            <rect x="10" y="8" width="8" height="14" rx="2" fill="none" stroke="#4ecdc4" stroke-width="1" opacity="0.4"/>
            <rect x="24" y="6" width="8" height="14" rx="2" fill="none" stroke="#4ecdc4" stroke-width="1" opacity="0.8">
              <animate attributeName="opacity" values="0.4;1;0.4" dur="3s" repeatCount="indefinite"/>
            </rect>
            <rect x="40" y="6" width="8" height="14" rx="2" fill="none" stroke="#4ecdc4" stroke-width="1" opacity="0.8">
              <animate attributeName="opacity" values="0.4;1;0.4" dur="3s" repeatCount="indefinite" begin="0.5s"/>
            </rect>
            <rect x="54" y="8" width="8" height="14" rx="2" fill="none" stroke="#4ecdc4" stroke-width="1" opacity="0.4"/>
            <!-- Routing arrows (top-k selection) -->
            <line x1="32" y1="30" x2="28" y2="20" stroke="#ff6b35" stroke-width="1" class="synapse"/>
            <line x1="40" y1="30" x2="44" y2="20" stroke="#ff6b35" stroke-width="1" class="synapse" style="animation-delay: 0.4s"/>
            <!-- 2D topology grid hint -->
            <circle cx="18" cy="58" r="2" fill="#ff6b35" opacity="0.3"/>
            <circle cx="30" cy="58" r="2" fill="#ff6b35" opacity="0.3"/>
            <circle cx="42" cy="58" r="2" fill="#ff6b35" opacity="0.3"/>
            <circle cx="54" cy="58" r="2" fill="#ff6b35" opacity="0.3"/>
            <text x="36" y="66" text-anchor="middle" fill="var(--text-muted)" font-size="4.5" font-family="monospace" opacity="0.5">top-k</text>
          </svg>
        </div>
        <h3>Thalamic Router</h3>
        <p>Chunk-level sparse top-k routing with a topology-aware 2D prior. Encourages temporal continuity in column selection, reducing parameter interference during streaming updates.</p>
        <span class="comp-tag">Routing</span>
      </div>

      <!-- Card 4: Cortical Columns -->
      <div class="comp-card" style="--card-accent: var(--cortex);">
        <div class="comp-icon">
          <svg viewBox="0 0 72 72" class="icon-animated">
            <defs>
              <radialGradient id="glow-cx" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="#4ecdc4" stop-opacity="0.25"/>
                <stop offset="100%" stop-color="#4ecdc4" stop-opacity="0"/>
              </radialGradient>
            </defs>
            <circle cx="36" cy="36" r="34" fill="url(#glow-cx)"/>
            <!-- Three cortical columns -->
            <g>
              <rect x="12" y="12" width="12" height="48" rx="3" fill="none" stroke="#4ecdc4" stroke-width="1.2" opacity="0.8"/>
              <!-- Layers in column -->
              <line x1="12" y1="24" x2="24" y2="24" stroke="#4ecdc4" stroke-width="0.5" opacity="0.3"/>
              <line x1="12" y1="36" x2="24" y2="36" stroke="#4ecdc4" stroke-width="0.5" opacity="0.3"/>
              <line x1="12" y1="48" x2="24" y2="48" stroke="#4ecdc4" stroke-width="0.5" opacity="0.3"/>
              <!-- Active neurons -->
              <circle cx="18" cy="18" r="2" fill="#4ecdc4" class="pulse" style="animation-delay: 0s"/>
              <circle cx="18" cy="42" r="2" fill="#4ecdc4" class="pulse" style="animation-delay: 0.8s"/>
            </g>
            <g>
              <rect x="30" y="12" width="12" height="48" rx="3" fill="none" stroke="#4ecdc4" stroke-width="1.2" opacity="0.8"/>
              <line x1="30" y1="24" x2="42" y2="24" stroke="#4ecdc4" stroke-width="0.5" opacity="0.3"/>
              <line x1="30" y1="36" x2="42" y2="36" stroke="#4ecdc4" stroke-width="0.5" opacity="0.3"/>
              <line x1="30" y1="48" x2="42" y2="48" stroke="#4ecdc4" stroke-width="0.5" opacity="0.3"/>
              <circle cx="36" cy="30" r="2" fill="#4ecdc4" class="pulse" style="animation-delay: 0.4s"/>
              <circle cx="36" cy="54" r="2" fill="#34d399" class="pulse" style="animation-delay: 1.2s"/>
            </g>
            <g>
              <rect x="48" y="12" width="12" height="48" rx="3" fill="none" stroke="#4ecdc4" stroke-width="1.2" opacity="0.8"/>
              <line x1="48" y1="24" x2="60" y2="24" stroke="#4ecdc4" stroke-width="0.5" opacity="0.3"/>
              <line x1="48" y1="36" x2="60" y2="36" stroke="#4ecdc4" stroke-width="0.5" opacity="0.3"/>
              <line x1="48" y1="48" x2="60" y2="48" stroke="#4ecdc4" stroke-width="0.5" opacity="0.3"/>
              <circle cx="54" cy="18" r="2" fill="#4ecdc4" class="pulse" style="animation-delay: 0.6s"/>
            </g>
            <!-- E/I labels -->
            <text x="18" y="33" text-anchor="middle" fill="#34d399" font-size="4" font-weight="bold" font-family="monospace">E</text>
            <text x="36" y="21" text-anchor="middle" fill="#ef4444" font-size="4" font-weight="bold" font-family="monospace">I</text>
          </svg>
        </div>
        <h3>Cortical Columns</h3>
        <p>Compact microcircuits with selective state-space updates, excitatory/inhibitory gating (SST·PV·VIP interneurons), adaptive membrane filtering, and causal within-chunk processing.</p>
        <span class="comp-tag">Computation</span>
      </div>

      <!-- Card 5: Hippocampal Memory -->
      <div class="comp-card" style="--card-accent: var(--hippocampus);">
        <div class="comp-icon">
          <svg viewBox="0 0 72 72" class="icon-animated">
            <defs>
              <radialGradient id="glow-hp" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="#a78bfa" stop-opacity="0.25"/>
                <stop offset="100%" stop-color="#a78bfa" stop-opacity="0"/>
              </radialGradient>
            </defs>
            <circle cx="36" cy="36" r="34" fill="url(#glow-hp)"/>
            <!-- Hippocampal shape -->
            <path d="M20 38 C20 26, 36 20, 52 28 C58 32, 56 42, 48 44 C42 46, 34 44, 28 46 C22 48, 18 44, 20 38Z" fill="none" stroke="#a78bfa" stroke-width="1.5" opacity="0.7"/>
            <!-- Memory slots (engrams) -->
            <circle cx="30" cy="32" r="3" fill="#a78bfa" opacity="0.6" class="pulse"/>
            <circle cx="42" cy="30" r="3" fill="#a78bfa" opacity="0.6" class="pulse" style="animation-delay: 0.5s"/>
            <circle cx="48" cy="38" r="3" fill="#a78bfa" opacity="0.6" class="pulse" style="animation-delay: 1s"/>
            <circle cx="36" cy="40" r="3" fill="#a78bfa" opacity="0.6" class="pulse" style="animation-delay: 1.5s"/>
            <!-- Retrieval beams -->
            <line x1="30" y1="32" x2="42" y2="30" stroke="#a78bfa" stroke-width="0.6" class="synapse" opacity="0.4"/>
            <line x1="42" y1="30" x2="48" y2="38" stroke="#a78bfa" stroke-width="0.6" class="synapse" opacity="0.4" style="animation-delay: 0.3s"/>
            <line x1="48" y1="38" x2="36" y2="40" stroke="#a78bfa" stroke-width="0.6" class="synapse" opacity="0.4" style="animation-delay: 0.6s"/>
            <!-- Label -->
            <text x="36" y="58" text-anchor="middle" fill="var(--text-muted)" font-size="4.5" font-family="monospace" opacity="0.5">Hopfield Net</text>
          </svg>
        </div>
        <h3>Associative Memory</h3>
        <p>Modern Hopfield Network with learned engram patterns. Chunk-level queries retrieve content-addressable long-range context, providing unlimited-range binding beyond lateral convolutions.</p>
        <span class="comp-tag">Memory</span>
      </div>

      <!-- Card 6: Dendritic Readout -->
      <div class="comp-card" style="--card-accent: var(--dendrite);">
        <div class="comp-icon">
          <svg viewBox="0 0 72 72" class="icon-animated">
            <defs>
              <radialGradient id="glow-dn" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="#34d399" stop-opacity="0.25"/>
                <stop offset="100%" stop-color="#34d399" stop-opacity="0"/>
              </radialGradient>
            </defs>
            <circle cx="36" cy="36" r="34" fill="url(#glow-dn)"/>
            <!-- Neuron body -->
            <ellipse cx="36" cy="40" rx="8" ry="6" fill="none" stroke="#34d399" stroke-width="1.5" opacity="0.8"/>
            <!-- Apical dendrite (top-down) -->
            <line x1="36" y1="34" x2="36" y2="14" stroke="#a78bfa" stroke-width="1.2" opacity="0.7"/>
            <line x1="36" y1="14" x2="28" y2="8" stroke="#a78bfa" stroke-width="0.8" opacity="0.5"/>
            <line x1="36" y1="14" x2="44" y2="8" stroke="#a78bfa" stroke-width="0.8" opacity="0.5"/>
            <text x="50" y="12" fill="#a78bfa" font-size="4.5" font-family="monospace" opacity="0.6">apical</text>
            <!-- Basal dendrite (bottom-up) -->
            <line x1="30" y1="44" x2="18" y2="52" stroke="#4ecdc4" stroke-width="1.2" opacity="0.7"/>
            <line x1="42" y1="44" x2="54" y2="52" stroke="#4ecdc4" stroke-width="1.2" opacity="0.7"/>
            <line x1="18" y1="52" x2="12" y2="58" stroke="#4ecdc4" stroke-width="0.8" opacity="0.5"/>
            <line x1="54" y1="52" x2="60" y2="58" stroke="#4ecdc4" stroke-width="0.8" opacity="0.5"/>
            <text x="8" y="66" fill="#4ecdc4" font-size="4.5" font-family="monospace" opacity="0.6">basal</text>
            <!-- Plateau potential indicator -->
            <circle cx="36" cy="24" r="3" fill="#34d399" opacity="0.5">
              <animate attributeName="r" values="2;4;2" dur="2s" repeatCount="indefinite"/>
              <animate attributeName="opacity" values="0.3;0.8;0.3" dur="2s" repeatCount="indefinite"/>
            </circle>
            <!-- Axon -->
            <line x1="36" y1="46" x2="36" y2="60" stroke="#34d399" stroke-width="1" opacity="0.6"/>
            <polygon points="33,60 36,66 39,60" fill="#34d399" opacity="0.6"/>
          </svg>
        </div>
        <h3>Dendritic Readout</h3>
        <p>Two-compartment neuron model: basal compartment receives bottom-up cortical drive while apical receives top-down hippocampal context. A sigmoid plateau potential gates interaction — matching Larkum et al. 1999.</p>
        <span class="comp-tag">Feedback</span>
      </div>

      <!-- Card 7: Cerebellar Corrector -->
      <div class="comp-card" style="--card-accent: var(--cerebellum);">
        <div class="comp-icon">
          <svg viewBox="0 0 72 72" class="icon-animated">
            <defs>
              <radialGradient id="glow-cb" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="#45b7d1" stop-opacity="0.25"/>
                <stop offset="100%" stop-color="#45b7d1" stop-opacity="0"/>
              </radialGradient>
            </defs>
            <circle cx="36" cy="36" r="34" fill="url(#glow-cb)"/>
            <!-- Cerebellum folia pattern -->
            <path d="M16 36 Q 22 28, 28 36 Q 34 44, 36 36 Q 38 28, 44 36 Q 50 44, 56 36" fill="none" stroke="#45b7d1" stroke-width="1.5" opacity="0.7"/>
            <path d="M18 42 Q 24 36, 30 42 Q 36 48, 42 42 Q 48 36, 54 42" fill="none" stroke="#45b7d1" stroke-width="1" opacity="0.4"/>
            <!-- Fast weight arrows -->
            <path d="M20 20 L 52 20" fill="none" stroke="#ff6b35" stroke-width="1" stroke-dasharray="3 2" opacity="0.6">
              <animate attributeName="stroke-dashoffset" from="0" to="-20" dur="1s" repeatCount="indefinite"/>
            </path>
            <text x="36" y="18" text-anchor="middle" fill="#ff6b35" font-size="4" font-family="monospace" opacity="0.6">fast Δ</text>
            <!-- Low rank indicator -->
            <text x="36" y="58" text-anchor="middle" fill="var(--text-muted)" font-size="4.5" font-family="monospace" opacity="0.5">rank-r</text>
            <!-- U and V matrices -->
            <rect x="14" y="50" width="10" height="6" rx="1" fill="none" stroke="#45b7d1" stroke-width="0.8" opacity="0.5"/>
            <text x="19" y="55" text-anchor="middle" fill="#45b7d1" font-size="4" font-family="monospace" opacity="0.6">V</text>
            <rect x="48" y="50" width="10" height="6" rx="1" fill="none" stroke="#45b7d1" stroke-width="0.8" opacity="0.5"/>
            <text x="53" y="55" text-anchor="middle" fill="#45b7d1" font-size="4" font-family="monospace" opacity="0.6">U</text>
          </svg>
        </div>
        <h3>Cerebellar Corrector</h3>
        <p>Low-rank fast-weight corrective pathway. Computes rank-r residuals from both the normalized input and cortex output, enabling rapid online adjustment without rewriting slow cortical parameters.</p>
        <span class="comp-tag">Correction</span>
      </div>

    </div>
  </div>
</section>

<div class="section-divider"></div>

<!-- ═══════════════════════════ ARCHITECTURE FLOW ═══════════════════════════ -->
<section id="method" class="arch-section">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Data Flow</div>
      <div class="section-title">The TRC² Block: Signal Flow</div>
      <div class="section-body" style="margin-bottom: 40px;">
        <p>Each TRC² layer follows a structured forward pass: normalize, modulate, predict, route, compute in parallel columns, refine routing, correct, and merge via residual connections.</p>
      </div>
    </div>

    <div class="arch-flow reveal">
      <div class="arch-node" style="--node-color: #fbbf24;">
        <div class="arch-node-label"><span class="dot" style="background:#fbbf24;"></span>Input</div>
        <div class="arch-node-title">X ∈ ℝ<sup>B×T×d</sup></div>
        <div class="arch-node-desc">Token + positional embeddings → RMSNorm</div>
      </div>

      <div class="arch-arrow"></div>

      <div class="arch-node" style="--node-color: #f472b6;">
        <div class="arch-node-label"><span class="dot" style="background:#f472b6;"></span>① Neuromodulator</div>
        <div class="arch-node-title">ModCtrl(U) → s<sub>route</sub>, s<sub>pred</sub>, s<sub>gain</sub></div>
        <div class="arch-node-desc">EMA deviation stats → 2-layer MLP → 3 control signals ∈ [0,1]</div>
      </div>

      <div class="arch-arrow"></div>

      <div class="arch-node" style="--node-color: #fbbf24;">
        <div class="arch-node-label"><span class="dot" style="background:#fbbf24;"></span>② Predictive Coding</div>
        <div class="arch-node-title">Û = U − (1 − s<sub>pred</sub>)·P̃</div>
        <div class="arch-node-desc">Causal conv prediction → error blend → aux ℒ<sub>pred</sub></div>
      </div>

      <div class="arch-arrow"></div>

      <div class="arch-node" style="--node-color: #ff6b35;">
        <div class="arch-node-label"><span class="dot" style="background:#ff6b35;"></span>③ Thalamic Router</div>
        <div class="arch-node-title">I, R, S = TopK(L, k)</div>
        <div class="arch-node-desc">Chunk-pool → Q·K<sup>T</sup> + topology prior → top-k softmax</div>
      </div>

      <div class="arch-arrow"></div>

      <div class="arch-node" style="--node-color: #a78bfa;">
        <div class="arch-node-label"><span class="dot" style="background:#a78bfa;"></span>④ Associative Memory</div>
        <div class="arch-node-title">C<sup>mem</sup> = HopfieldRetrieve(Ū, Ξ)</div>
        <div class="arch-node-desc">Chunk queries → normalized Hopfield → content-addressable context</div>
      </div>

      <div class="arch-arrow"></div>

      <div class="arch-node" style="--node-color: #4ecdc4; border-width: 2px;">
        <div class="arch-node-label"><span class="dot" style="background:#4ecdc4;"></span>⑤ Parallel Cortex</div>
        <div class="arch-node-title">Y = Cortex(Û, I, R, C<sup>mem</sup>)</div>
        <div class="arch-node-desc">Dense projection → E/I gating → adaptive membrane → causal conv → dendritic readout → routed mixture</div>
      </div>

      <div class="arch-arrow"></div>

      <div class="arch-node" style="--node-color: #fb923c;">
        <div class="arch-node-label"><span class="dot" style="background:#fb923c;"></span>⑥ Routing Refinement</div>
        <div class="arch-node-title">R′ = softmax(S + α<sub>fb</sub>·S<sup>fb</sup>)</div>
        <div class="arch-node-desc">Cortex output → feedback projection → refine weights → 2nd cortex pass</div>
      </div>

      <div class="arch-arrow"></div>

      <div class="arch-node" style="--node-color: #45b7d1;">
        <div class="arch-node-label"><span class="dot" style="background:#45b7d1;"></span>⑦ Cerebellar Correction</div>
        <div class="arch-node-title">Δ = SiLU(Z)·V·U<sup>T</sup></div>
        <div class="arch-node-desc">Low-rank fast-weight residual from [Û; Y] → rank-r correction</div>
      </div>

      <div class="arch-arrow"></div>

      <div class="arch-node" style="--node-color: #34d399;">
        <div class="arch-node-label"><span class="dot" style="background:#34d399;"></span>Output</div>
        <div class="arch-node-title">X<sup>+</sup> = X + Drop(g<sub>gain</sub>⊙Y + Δ)</div>
        <div class="arch-node-desc">Global gain modulation → residual + dropout → RMSNorm → SwiGLU FFN → residual</div>
      </div>
    </div>

    <!-- Key equations -->
    <div class="reveal" style="margin-top: 56px;">
      <div class="section-label">Key Equations</div>

      <div class="equation-block" data-eq="(3-5)">
        U = RMSNorm(X),&nbsp;&nbsp;&nbsp;(s_route, s_pred, s_gain) = ModCtrl(U),&nbsp;&nbsp;&nbsp;Û = U − (1−s_pred)·P̃
      </div>

      <div class="equation-block" data-eq="(6-8)">
        (I, R, S, ℒ_route) = Router(Û),&nbsp;&nbsp;&nbsp;C^mem = AssocMem(Ū),&nbsp;&nbsp;&nbsp;Y = Cortex(Û, I, R, C^mem)
      </div>

      <div class="equation-block" data-eq="(13-14)">
        X̃ = X + Drop(g_gain⊙Y + Δ),&nbsp;&nbsp;&nbsp;X⁺ = X̃ + Drop(SwiGLU(RMSNorm(X̃)))
      </div>

      <div class="equation-block" data-eq="(53)">
        ℒ_train = ℒ_CE + 0.1·ℒ^Σ_pred + ℒ^Σ_route
      </div>
    </div>
  </div>
</section>

<div class="section-divider"></div>

<!-- ═══════════════════════════ ANIMATED TOKEN FLOW ═══════════════════════════ -->
<section class="token-flow-section">
  <div class="wide-container">
    <div class="reveal">
      <div class="section-label">Live Visualization</div>
      <div class="section-title">Animated Token Flow Through TRC² Block</div>
      <div class="section-body">
        <p>Watch token particles flow through the complete TRC² block — from input normalization through thalamic routing, into active cortical columns with E/I gating, past the Hopfield associative memory, through dendritic readout and cortico-thalamic feedback, and finally the cerebellar fast-weight corrector merging into the residual stream.</p>
      </div>
    </div>

    <div class="canvas-outer reveal">
      <canvas id="tokenFlowCanvas"></canvas>
      <div class="canvas-controls">
        <button id="btnSpeed" class="active" onclick="toggleSpeed()">1× Speed</button>
        <button id="btnLabels" class="active" onclick="toggleLabels()">Labels</button>
      </div>
      <div class="canvas-legend">
        <div class="canvas-legend-item"><div class="canvas-legend-dot" style="background:#f472b6"></div>Neuromodulator</div>
        <div class="canvas-legend-item"><div class="canvas-legend-dot" style="background:#fbbf24"></div>Predictive Cortex</div>
        <div class="canvas-legend-item"><div class="canvas-legend-dot" style="background:#ff6b35"></div>Thalamic Router</div>
        <div class="canvas-legend-item"><div class="canvas-legend-dot" style="background:#4ecdc4"></div>Active Column</div>
        <div class="canvas-legend-item"><div class="canvas-legend-dot" style="background:rgba(255,255,255,0.2)"></div>Inactive Column</div>
        <div class="canvas-legend-item"><div class="canvas-legend-dot" style="background:#a78bfa"></div>Hopfield Memory</div>
        <div class="canvas-legend-item"><div class="canvas-legend-dot" style="background:#34d399"></div>Dendritic Readout</div>
        <div class="canvas-legend-item"><div class="canvas-legend-dot" style="background:#fb923c"></div>CT Feedback</div>
        <div class="canvas-legend-item"><div class="canvas-legend-dot" style="background:#45b7d1"></div>Cerebellar Δ</div>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"></div>

<!-- ═══════════════════════════ RESULTS ═══════════════════════════ -->
<section id="results">
  <div class="wide-container">
    <div class="reveal">
      <div class="section-label">Experiments</div>
      <div class="section-title">Results</div>
      <div class="section-body">
        <p>Evaluated on C4, WikiText-103, and LAMBADA with 4×V100 GPUs, 2.88B tokens, against parameter-matched Transformer and Mamba baselines. TRC² achieves dramatically lower perplexity and higher BLEU, with substantially reduced continual-learning forgetting.</p>
      </div>
    </div>

    <!-- Table 1 -->
    <div class="reveal" style="margin-top: 40px;">
      <h3 style="font-family: var(--font-display); font-size: 1.3rem; margin-bottom: 16px;">Table 1 — Evaluation Performance & Efficiency</h3>
      <div class="results-table-wrap">
        <table class="results-table">
          <thead>
            <tr>
              <th>Model</th>
              <th>Params</th>
              <th>d<sub>m</sub></th>
              <th>PPL C4 ↓</th>
              <th>PPL Wiki ↓</th>
              <th>PPL LAM ↓</th>
              <th>BLEU C4 ↑</th>
              <th>BLEU Wiki ↑</th>
              <th>BLEU LAM ↑</th>
              <th>Tok/s ↑</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Transformer</td>
              <td>162M</td>
              <td>768</td>
              <td>60.70</td>
              <td>215.18</td>
              <td>105.72</td>
              <td>8.12</td>
              <td>8.23</td>
              <td>5.09</td>
              <td>~127k</td>
            </tr>
            <tr>
              <td>Mamba</td>
              <td>176M</td>
              <td>768</td>
              <td>70.45</td>
              <td>357.67</td>
              <td>116.73</td>
              <td>6.90</td>
              <td>2.87</td>
              <td>3.97</td>
              <td>~108k</td>
            </tr>
            <tr class="highlight-row">
              <td><strong>TRC² (ours)</strong></td>
              <td>169M</td>
              <td>512</td>
              <td class="best-val">2.00</td>
              <td class="best-val">2.56</td>
              <td class="best-val">2.02</td>
              <td class="best-val">71.66</td>
              <td class="best-val">66.57</td>
              <td class="best-val">70.07</td>
              <td>~57k</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Perplexity Chart -->
    <div class="chart-container reveal">
      <div class="chart-title">Perplexity Comparison — C4 (lower is better)</div>
      <div class="chart-bars" id="ppl-chart">
        <div class="chart-bar-row">
          <div class="chart-bar-label">Transformer</div>
          <div class="chart-bar-track">
            <div class="chart-bar-fill transformer" style="width: 0%;" data-target="86" data-val="60.70"></div>
          </div>
        </div>
        <div class="chart-bar-row">
          <div class="chart-bar-label">Mamba</div>
          <div class="chart-bar-track">
            <div class="chart-bar-fill mamba" style="width: 0%;" data-target="100" data-val="70.45"></div>
          </div>
        </div>
        <div class="chart-bar-row">
          <div class="chart-bar-label">TRC² (ours)</div>
          <div class="chart-bar-track">
            <div class="chart-bar-fill trc2" style="width: 0%;" data-target="2.8" data-val="2.00"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- BLEU Chart -->
    <div class="chart-container reveal">
      <div class="chart-title">BLEU Score — C4 (higher is better)</div>
      <div class="chart-bars" id="bleu-chart">
        <div class="chart-bar-row">
          <div class="chart-bar-label">Transformer</div>
          <div class="chart-bar-track">
            <div class="chart-bar-fill transformer" style="width: 0%;" data-target="11.3" data-val="8.12"></div>
          </div>
        </div>
        <div class="chart-bar-row">
          <div class="chart-bar-label">Mamba</div>
          <div class="chart-bar-track">
            <div class="chart-bar-fill mamba" style="width: 0%;" data-target="9.6" data-val="6.90"></div>
          </div>
        </div>
        <div class="chart-bar-row">
          <div class="chart-bar-label">TRC² (ours)</div>
          <div class="chart-bar-track">
            <div class="chart-bar-fill trc2" style="width: 0%;" data-target="100" data-val="71.66"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Table 2 -->
    <div class="reveal" style="margin-top: 40px;">
      <h3 style="font-family: var(--font-display); font-size: 1.3rem; margin-bottom: 16px;">Table 2 — Continual Learning: Average Forgetting</h3>
      <div class="results-table-wrap">
        <table class="results-table">
          <thead>
            <tr>
              <th>Model</th>
              <th colspan="3" style="text-align:center;">Last Step ↓</th>
              <th colspan="3" style="text-align:center;">Normalized AUC ↓</th>
            </tr>
            <tr>
              <th></th>
              <th>PPL</th>
              <th>TokAcc</th>
              <th>BLEU</th>
              <th>PPL</th>
              <th>TokAcc</th>
              <th>BLEU</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Transformer</td>
              <td class="best-val">0.0000</td>
              <td>0.0014</td>
              <td>0.3757</td>
              <td>0.0669</td>
              <td>0.0008</td>
              <td>0.1684</td>
            </tr>
            <tr>
              <td>Mamba</td>
              <td class="best-val">0.0000</td>
              <td class="best-val">0.0006</td>
              <td>0.0900</td>
              <td>0.3371</td>
              <td>0.0011</td>
              <td>0.1957</td>
            </tr>
            <tr class="highlight-row">
              <td><strong>TRC² (ours)</strong></td>
              <td>0.0110</td>
              <td>0.0010</td>
              <td class="best-val">0.0435</td>
              <td class="best-val">0.0018</td>
              <td class="best-val">0.0008</td>
              <td class="best-val">0.0981</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="highlight-block reveal" style="margin-top: 32px;">
      <strong>Key insight:</strong> TRC² shows 37× lower normalized PPL forgetting AUC than Transformer and 187× lower than Mamba — the model retains earlier behavior consistently over the full stream, not just at the final step.
    </div>
  </div>
</section>

<div class="section-divider"></div>

<!-- ═══════════════════════════ DISCUSSION ═══════════════════════════ -->
<section id="discussion">
  <div class="container">
    <div class="reveal">
      <div class="section-label">Discussion & Conclusion</div>
      <div class="section-title">Making Interference Control Part of the Forward Pass</div>
      <div class="section-body">
        <p>The results support TRC²'s core design claim: continual learning improves when plasticity is allocated to a small, explicit pathway while keeping most representational structure stable. The normalized forgetting AUC — tracking behavior over the <em>full</em> training stream — shows markedly lower forgetting than both baselines.</p>

        <p>TRC² trades raw throughput for structured sparsity and online-correctable computation. The chunked routing scheme amortizes router overhead, but end-to-end performance remains sensitive to kernel fusion and memory layout. The favorable scaling regime appears when routing decisions are stable across neighboring tokens and column-local scans stay contiguous in memory.</p>

        <p>Several mechanisms likely contribute: topology-aware routing encourages temporal continuity, reducing parameter interference. Excitatory-inhibitory gating suppresses unstable activations before residual propagation. The cerebellar corrector provides fast stream-driven adjustment without rewriting slower parameters.</p>

        <p>Future work should extend evaluation to larger scales and longer contexts, study router stability under harder non-stationary streams, and couple the corrective pathway with deployment-time constraints for bounded, interpretable, and reversible adaptation.</p>
      </div>
    </div>
  </div>
</section>

<!-- ═══════════════════════════ FOOTER ═══════════════════════════ -->
<footer class="footer">
  <div class="container">
    <p>TRC² — Thalamically Routed Cortical Columns · Afshin Khadangi · SnT, University of Luxembourg</p>
    <p style="margin-top: 8px;">arXiv:2602.22479v1 [cs.LG] · February 2026 · Working Paper</p>
  </div>
</footer>

<!-- ═══════════════════════════ SCRIPTS ═══════════════════════════ -->
<script>
// ── Theme Toggle ──
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  html.setAttribute('data-theme', current === 'dark' ? 'light' : 'dark');
}

// ── Navigation show on scroll ──
const nav = document.getElementById('nav');
let lastScroll = 0;
window.addEventListener('scroll', () => {
  const y = window.scrollY;
  if (y > 400) nav.classList.add('visible');
  else nav.classList.remove('visible');
  lastScroll = y;
});

// ── Scroll reveal ──
const observerOptions = { threshold: 0.1, rootMargin: '0px 0px -60px 0px' };
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add('visible');
      // Animate chart bars
      if (entry.target.querySelector('.chart-bar-fill')) {
        entry.target.querySelectorAll('.chart-bar-fill').forEach(bar => {
          bar.style.width = bar.dataset.target + '%';
        });
      }
    }
  });
}, observerOptions);
document.querySelectorAll('.reveal').forEach(el => observer.observe(el));

// ── Neural Network Canvas ──
const canvas = document.getElementById('neural-canvas');
const ctx = canvas.getContext('2d');
let nodes = [];
let animId;

function resizeCanvas() {
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
}

function initNodes() {
  nodes = [];
  const count = Math.min(80, Math.floor(canvas.width * canvas.height / 12000));
  for (let i = 0; i < count; i++) {
    nodes.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      vx: (Math.random() - 0.5) * 0.4,
      vy: (Math.random() - 0.5) * 0.4,
      r: Math.random() * 2 + 1,
      pulse: Math.random() * Math.PI * 2
    });
  }
}

function drawNeural() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const time = Date.now() * 0.001;
  const theme = document.documentElement.getAttribute('data-theme');
  const lineColor = theme === 'dark' ? 'rgba(78,205,196,' : 'rgba(78,205,196,';
  const nodeColor = theme === 'dark' ? 'rgba(78,205,196,' : 'rgba(78,205,196,';

  // Update positions
  nodes.forEach(n => {
    n.x += n.vx;
    n.y += n.vy;
    if (n.x < 0 || n.x > canvas.width) n.vx *= -1;
    if (n.y < 0 || n.y > canvas.height) n.vy *= -1;
    n.pulse += 0.02;
  });

  // Draw connections
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      const dx = nodes[i].x - nodes[j].x;
      const dy = nodes[i].y - nodes[j].y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 150) {
        const alpha = (1 - dist / 150) * 0.15;
        ctx.beginPath();
        ctx.moveTo(nodes[i].x, nodes[i].y);
        ctx.lineTo(nodes[j].x, nodes[j].y);
        ctx.strokeStyle = lineColor + alpha + ')';
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }
    }
  }

  // Draw nodes
  nodes.forEach(n => {
    const pulseR = n.r + Math.sin(n.pulse) * 0.5;
    const alpha = 0.4 + Math.sin(n.pulse) * 0.2;
    ctx.beginPath();
    ctx.arc(n.x, n.y, pulseR, 0, Math.PI * 2);
    ctx.fillStyle = nodeColor + alpha + ')';
    ctx.fill();
  });

  animId = requestAnimationFrame(drawNeural);
}

resizeCanvas();
initNodes();
drawNeural();
window.addEventListener('resize', () => { resizeCanvas(); initNodes(); });

// ── Floating particles ──
const particlesContainer = document.getElementById('particles');
function createParticle() {
  const p = document.createElement('div');
  p.className = 'particle';
  p.style.left = Math.random() * 100 + '%';
  p.style.animationDuration = (15 + Math.random() * 25) + 's';
  p.style.animationDelay = Math.random() * 10 + 's';
  p.style.width = p.style.height = (1 + Math.random() * 2) + 'px';
  particlesContainer.appendChild(p);
}
for (let i = 0; i < 30; i++) createParticle();

// ── Smooth scroll for nav links ──
document.querySelectorAll('.nav-links a').forEach(a => {
  a.addEventListener('click', e => {
    e.preventDefault();
    const target = document.querySelector(a.getAttribute('href'));
    if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
  });
});

// ═══════════════════════════════════════════════════
// ───── ANIMATED TOKEN FLOW CANVAS ─────
// ═══════════════════════════════════════════════════
(function() {
  const canvas = document.getElementById('tokenFlowCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  let W, H, dpr;
  let showLabels = true;
  let speedMult = 1;

  const COLS = 8;
  const ACTIVE = [1, 3, 6];
  const MEMORY_SLOTS = 5;

  function resize() {
    dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    W = rect.width;
    H = rect.height;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resize();
  window.addEventListener('resize', resize);

  /* ── Layout zones (recomputed per frame to handle resize) ── */
  function layout() {
    // Three zones: left sidebar (memory), center (bars/columns), right sidebar (feedback+corrector)
    const L = {
      // Horizontal
      memCX:   50,             // memory panel center-x
      memW:    44,             // memory panel width
      barX:    96,             // bars left edge
      barW:    W - 250,        // bars width (leaves ~154px right)
      skipX:   86,             // skip connection x
      fbX:     W - 112,        // feedback loop x
      corrX:   W - 62,        // corrector center x
      // Vertical stages – generous spacing
      input:   34,
      norm:    66,
      neuro:   112,
      pred:    164,
      router:  220,
      colTop:  282,
      colBot:  488,
      dendrite:538,
      lateral: 578,
      gain:    636,
      ffn:     688,
      output:  738
    };
    L.midX  = L.barX + L.barW / 2;
    L.barH  = 28;
    L.barR  = L.barX + L.barW; // bar right edge
    return L;
  }

  function colX(i, L) {
    const pad = 22;
    return L.barX + pad + i * ((L.barW - pad * 2) / (COLS - 1));
  }

  // ══════════════════════════════════════
  // PARTICLE SYSTEMS
  // ══════════════════════════════════════

  class FlowParticle {
    constructor() { this.reset(); }
    reset() {
      this.phase = 0;
      this.col = ACTIVE[Math.floor(Math.random() * ACTIVE.length)];
      this.t = Math.random();
      this.speed = 0.003 + Math.random() * 0.004;
      this.size = 1.8 + Math.random() * 1.5;
      this.hue = Math.random() > 0.5 ? '78,205,196' : '255,107,53';
      this.alpha = 1;
    }
    update() {
      this.t += this.speed * speedMult;
      if (this.t >= 1) { this.t = 0; this.phase++; if (this.phase > 7) this.reset(); }
    }
    getPos(L) {
      const cx = colX(this.col, L);
      const mx = L.midX;
      switch (this.phase) {
        case 0: return { x: mx + (cx - mx) * this.t * 0.15, y: L.input + (L.router - L.input) * this.t };
        case 1: return { x: mx + (cx - mx) * (0.15 + this.t * 0.85), y: L.router + (L.colTop - L.router) * this.t };
        case 2: return { x: cx + Math.sin(this.t * Math.PI * 5) * 5, y: L.colTop + (L.colBot - L.colTop) * this.t };
        case 3: return { x: cx + (mx - cx) * this.t * 0.3, y: L.colBot + (L.dendrite - L.colBot) * this.t };
        case 4: return { x: cx + (mx - cx) * (0.3 + this.t * 0.35), y: L.dendrite + (L.lateral - L.dendrite) * this.t };
        case 5: return { x: cx + (mx - cx) * (0.65 + this.t * 0.35), y: L.lateral + (L.gain - L.lateral) * this.t };
        case 6: return { x: mx, y: L.gain + (L.output - L.gain) * this.t };
        case 7: this.alpha = 1 - this.t; return { x: mx, y: L.output + 18 * this.t };
        default: return { x: mx, y: L.input };
      }
    }
    draw(L) {
      const p = this.getPos(L);
      ctx.beginPath();
      ctx.arc(p.x, p.y, this.size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${this.hue},${this.alpha * 0.85})`;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(p.x, p.y, this.size * 3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${this.hue},${this.alpha * 0.07})`;
      ctx.fill();
    }
  }

  class CorrectorParticle {
    constructor() { this.reset(); }
    reset() { this.t = Math.random(); this.speed = 0.004 + Math.random() * 0.003; this.size = 1.5 + Math.random(); }
    update() { this.t += this.speed * speedMult; if (this.t >= 1) this.reset(); }
    draw(L) {
      const yy = (L.router + 30) + (L.gain - L.router - 40) * this.t;
      ctx.beginPath();
      ctx.arc(L.corrX, yy, this.size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(69,183,209,${0.7 + Math.sin(this.t * Math.PI) * 0.3})`;
      ctx.fill();
    }
  }

  class FeedbackParticle {
    constructor() { this.reset(); }
    reset() { this.t = Math.random(); this.speed = 0.005 + Math.random() * 0.003; this.size = 1.3; }
    update() { this.t += this.speed * speedMult; if (this.t >= 1) this.reset(); }
    draw(L) {
      const xRight = L.fbX;
      const yBot = L.lateral;
      const yTop = L.router;
      let x, y;
      if (this.t < 0.25) {
        const lt = this.t / 0.25;
        x = L.barR + (xRight - L.barR) * lt;
        y = yBot;
      } else if (this.t < 0.70) {
        const lt = (this.t - 0.25) / 0.45;
        x = xRight;
        y = yBot - (yBot - yTop) * lt;
      } else {
        const lt = (this.t - 0.70) / 0.30;
        x = xRight - (xRight - L.barR) * lt;
        y = yTop;
      }
      ctx.beginPath();
      ctx.arc(x, y, this.size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(251,146,60,${0.6 + Math.sin(this.t * Math.PI * 2) * 0.3})`;
      ctx.fill();
    }
  }

  class MemoryParticle {
    constructor() { this.reset(); }
    reset() { this.t = Math.random(); this.speed = 0.006 + Math.random() * 0.004; this.slot = Math.floor(Math.random() * MEMORY_SLOTS); this.size = 1.2; }
    update() { this.t += this.speed * speedMult; if (this.t >= 1) this.reset(); }
    draw(L) {
      const memTopY = L.colTop + 20;
      const memBotY = L.colBot - 20;
      const slotY = memTopY + 22 + this.slot * ((memBotY - memTopY - 44) / (MEMORY_SLOTS - 1));
      const targetX = colX(ACTIVE[0], L) - 18;
      const targetY = (L.colTop + L.colBot) / 2;
      let x, y;
      if (this.t < 0.4) {
        x = L.memCX; y = slotY;
        this.size = 1.2 + Math.sin(this.t / 0.4 * Math.PI) * 1.5;
      } else {
        const lt = (this.t - 0.4) / 0.6;
        x = L.memCX + (targetX - L.memCX) * lt;
        y = slotY + (targetY - slotY) * lt;
      }
      ctx.beginPath();
      ctx.arc(x, y, this.size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(167,139,250,${0.5 + Math.sin(this.t * Math.PI) * 0.4})`;
      ctx.fill();
    }
  }

  const flowParticles = Array.from({ length: 42 }, () => new FlowParticle());
  const corrParticles = Array.from({ length: 7 }, () => new CorrectorParticle());
  const fbParticles   = Array.from({ length: 6 }, () => new FeedbackParticle());
  const memParticles  = Array.from({ length: 7 }, () => new MemoryParticle());

  let time = 0;

  // ── Drawing helpers ──
  function rr(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function drawBar(x, y, w, h, fill, stroke, label, lcol) {
    rr(x, y, w, h, 6);
    ctx.fillStyle = fill; ctx.fill();
    ctx.strokeStyle = stroke; ctx.lineWidth = 1; ctx.stroke();
    if (showLabels && label) {
      ctx.font = `600 ${h >= 28 ? 9.5 : 8}px "DM Mono","JetBrains Mono",monospace`;
      ctx.fillStyle = lcol || stroke;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(label, x + w / 2, y + h / 2);
    }
  }

  function lbl(x, y, text, color, align, sz) {
    if (!showLabels) return;
    ctx.font = `500 ${sz || 8}px "DM Mono","JetBrains Mono",monospace`;
    ctx.fillStyle = color || 'rgba(255,255,255,0.45)';
    ctx.textAlign = align || 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(text, x, y);
  }

  function conn(x1, y1, x2, y2, color, w, dash) {
    ctx.beginPath();
    if (dash) ctx.setLineDash(dash);
    ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
    ctx.strokeStyle = color; ctx.lineWidth = w || 1; ctx.stroke();
    if (dash) ctx.setLineDash([]);
  }

  // ══════════════════════════════════════
  // MAIN DRAW LOOP
  // ══════════════════════════════════════
  function draw() {
    time += 0.016;
    ctx.clearRect(0, 0, W, H);
    const L = layout();
    const { barX, barW, barH, barR, midX, memCX, memW: mW, fbX, corrX, skipX } = L;

    // ── Background glow ──
    const grd = ctx.createRadialGradient(midX, H * 0.4, 0, midX, H * 0.4, W * 0.55);
    grd.addColorStop(0, 'rgba(78,205,196,0.04)');
    grd.addColorStop(0.5, 'rgba(167,139,250,0.02)');
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, W, H);

    // ═══════════ STAGE 1: INPUT ═══════════
    lbl(midX, L.input, 'X ∈ ℝᴮˣᵀˣᵈ  —  TOKEN INPUT', 'rgba(255,255,255,0.5)', 'center', 10);
    conn(midX, L.input + 10, midX, L.norm - barH / 2 - 2, 'rgba(255,255,255,0.1)', 1);

    // ═══════════ STAGE 2: RMSNORM ═══════════
    drawBar(barX, L.norm - barH / 2, barW, barH, 'rgba(100,116,139,0.12)', 'rgba(100,116,139,0.4)',
      'RMSNorm(X)  →  U', 'rgba(100,116,139,0.8)');
    conn(midX, L.norm + barH / 2, midX, L.neuro - barH / 2 - 2, 'rgba(255,255,255,0.1)', 1);

    // ═══════════ STAGE 3: NEUROMODULATOR ═══════════
    drawBar(barX, L.neuro - barH / 2, barW, barH, 'rgba(244,114,182,0.1)', 'rgba(244,114,182,0.45)',
      '① NEUROMODULATOR  →  sᵣₒᵤₜₑ · sₚᵣₑ · sᵍₐᵢₙ', 'rgba(244,114,182,0.85)');

    // Signal indicators
    const sigY = L.neuro + barH / 2 + 16;
    const sigs = [
      { lab: 'D (route)', col: '#ff6b35', dx: -90 },
      { lab: 'ACh (pred)', col: '#4ecdc4', dx: 0 },
      { lab: 'NE (gain)', col: '#fbbf24', dx: 90 }
    ];
    sigs.forEach((s, i) => {
      const sx = midX + s.dx;
      const pr = 4 + Math.sin(time * 2.5 + i * 2) * 2;
      ctx.beginPath(); ctx.arc(sx, sigY, pr, 0, Math.PI * 2);
      ctx.fillStyle = s.col + '44'; ctx.fill();
      ctx.beginPath(); ctx.arc(sx, sigY, 3, 0, Math.PI * 2);
      ctx.fillStyle = s.col; ctx.fill();
      lbl(sx, sigY + 13, s.lab, s.col + '99', 'center', 6.5);
    });
    conn(midX, sigY + 20, midX, L.pred - barH / 2 - 2, 'rgba(255,255,255,0.08)', 1);

    // ═══════════ STAGE 4: PREDICTIVE CORTEX ═══════════
    drawBar(barX, L.pred - barH / 2, barW, barH, 'rgba(251,191,36,0.1)', 'rgba(251,191,36,0.45)',
      '② PREDICTIVE CODING   Û = U − (1−sₚᵣₑ)·P̃', 'rgba(251,191,36,0.85)');
    lbl(barR + 6, L.pred, 'ℒₚᵣₑ', 'rgba(251,191,36,0.45)', 'left', 7);
    conn(midX, L.pred + barH / 2, midX, L.router - barH / 2 - 4, 'rgba(255,255,255,0.1)', 1);

    // ═══════════ STAGE 5: THALAMIC ROUTER ═══════════
    const routerH = 32;
    drawBar(barX, L.router - routerH / 2, barW, routerH, 'rgba(255,107,53,0.12)', 'rgba(255,107,53,0.5)',
      '③ THALAMIC ROUTER  ·  chunk → Q·Kᵀ + topo-2D → top-k', 'rgba(255,107,53,0.9)');
    lbl(barR + 6, L.router, 'ℒᵣₒᵤₜₑ', 'rgba(255,107,53,0.45)', 'left', 7);

    // Topology grid hint (safely above router, inside bar area)
    if (showLabels) {
      const gx = barX + barW - 60;
      const gy = L.router - routerH / 2 + 5;
      for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++) {
        const on = (r === 0 && c === 1) || (r === 1 && c === 0) || (r === 2 && c === 2);
        ctx.beginPath(); ctx.arc(gx + c * 8, gy + r * 8, 2, 0, Math.PI * 2);
        ctx.fillStyle = on ? 'rgba(255,107,53,0.75)' : 'rgba(255,107,53,0.2)'; ctx.fill();
      }
    }

    // ── Router → Column connections ──
    for (let i = 0; i < COLS; i++) {
      const isA = ACTIVE.includes(i);
      const cx = colX(i, L);
      conn(cx, L.router + routerH / 2, cx, L.colTop,
        isA ? 'rgba(255,107,53,0.35)' : 'rgba(255,255,255,0.04)', isA ? 1.5 : 0.5);
      if (isA) {
        ctx.beginPath(); ctx.moveTo(cx - 3, L.colTop - 2);
        ctx.lineTo(cx, L.colTop + 2); ctx.lineTo(cx + 3, L.colTop - 2);
        ctx.fillStyle = 'rgba(255,107,53,0.4)'; ctx.fill();
      }
    }

    // ═══════════ ASSOCIATIVE MEMORY (LEFT PANEL) ═══════════
    const memTopY = L.colTop + 16;
    const memBotY = L.colBot - 16;
    rr(memCX - mW / 2, memTopY, mW, memBotY - memTopY, 8);
    ctx.fillStyle = 'rgba(167,139,250,0.07)'; ctx.fill();
    ctx.strokeStyle = 'rgba(167,139,250,0.3)'; ctx.lineWidth = 1; ctx.stroke();

    lbl(memCX, memTopY - 12, '④ HOPFIELD MEM', 'rgba(167,139,250,0.65)', 'center', 6.5);

    for (let s = 0; s < MEMORY_SLOTS; s++) {
      const sy = memTopY + 22 + s * ((memBotY - memTopY - 44) / (MEMORY_SLOTS - 1));
      const pr = 3 + Math.sin(time * 1.8 + s * 1.2) * 1.5;
      ctx.beginPath(); ctx.arc(memCX, sy, pr, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(167,139,250,${0.2 + Math.sin(time * 1.8 + s * 1.2) * 0.15})`; ctx.fill();
      ctx.beginPath(); ctx.arc(memCX, sy, 2, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(167,139,250,0.65)'; ctx.fill();
      lbl(memCX + 16, sy, 'Ξ' + s, 'rgba(167,139,250,0.3)', 'left', 5.5);
    }
    // Dashed retrieval line to first active column
    const memMidY = (memTopY + memBotY) / 2;
    conn(memCX + mW / 2, memMidY, colX(ACTIVE[0], L) - 20, memMidY, 'rgba(167,139,250,0.18)', 0.8, [3, 3]);
    lbl((memCX + mW / 2 + colX(ACTIVE[0], L) - 20) / 2, memMidY - 10, 'Cᵐᵉᵐ', 'rgba(167,139,250,0.38)', 'center', 6.5);

    // ═══════════ CORTICAL COLUMNS ═══════════
    for (let i = 0; i < COLS; i++) {
      const isA = ACTIVE.includes(i);
      const cx = colX(i, L);
      const cw = 36;
      const ch = L.colBot - L.colTop;

      rr(cx - cw / 2, L.colTop, cw, ch, 7);
      ctx.fillStyle = isA ? 'rgba(78,205,196,0.07)' : 'rgba(255,255,255,0.015)';
      ctx.fill();
      ctx.strokeStyle = isA ? 'rgba(78,205,196,0.4)' : 'rgba(255,255,255,0.06)';
      ctx.lineWidth = isA ? 1.5 : 0.5;
      ctx.stroke();

      if (isA) {
        // E/I gating
        const gy = L.colTop + 22;
        const es = 3.5 + Math.sin(time * 3 + i * 1.5) * 1.2;
        ctx.beginPath(); ctx.arc(cx - 7, gy, es, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(52,211,153,${0.35 + Math.sin(time * 3 + i) * 0.2})`; ctx.fill();
        lbl(cx - 7, gy + 10, 'E', 'rgba(52,211,153,0.55)', 'center', 5.5);
        ctx.beginPath(); ctx.arc(cx + 7, gy, 2.5, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(239,68,68,${0.3 + Math.sin(time * 2.5 + i * 2) * 0.2})`; ctx.fill();
        lbl(cx + 7, gy + 10, 'I', 'rgba(239,68,68,0.45)', 'center', 5.5);

        // SSM state
        const ssmY = L.colTop + 52;
        const sH = 22 + Math.sin(time * 2 + i * 0.7) * 6;
        rr(cx - 9, ssmY, 18, sH, 3);
        ctx.fillStyle = `rgba(78,205,196,${0.12 + Math.sin(time * 2 + i) * 0.06})`; ctx.fill();
        ctx.strokeStyle = 'rgba(78,205,196,0.25)'; ctx.lineWidth = 0.5; ctx.stroke();
        lbl(cx, ssmY + sH / 2, 'SSM', 'rgba(78,205,196,0.5)', 'center', 6);

        // Adaptive membrane wave
        const mY = ssmY + sH + 14;
        ctx.beginPath(); ctx.moveTo(cx - 10, mY);
        for (let t = 0; t <= 1; t += 0.06) {
          ctx.lineTo(cx - 10 + t * 20, mY + Math.sin(t * Math.PI * 3 + time * 3 + i) * 3.5);
        }
        ctx.strokeStyle = `rgba(78,205,196,${0.35 + Math.sin(time * 1.5 + i) * 0.15})`; ctx.lineWidth = 0.8; ctx.stroke();
        lbl(cx, mY + 10, 'α·A', 'rgba(78,205,196,0.35)', 'center', 5.5);

        // VIP disinhibition
        const vY = mY + 24;
        ctx.beginPath(); ctx.arc(cx, vY, 3.5, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(167,139,250,${0.3 + Math.sin(time * 2.2 + i * 1.7) * 0.22})`; ctx.fill();
        lbl(cx, vY + 10, 'VIP', 'rgba(167,139,250,0.4)', 'center', 5.5);

        // Readout
        const rY = L.colBot - 28;
        rr(cx - 9, rY, 18, 12, 3);
        ctx.fillStyle = 'rgba(52,211,153,0.08)'; ctx.fill();
        ctx.strokeStyle = 'rgba(52,211,153,0.25)'; ctx.lineWidth = 0.5; ctx.stroke();
        lbl(cx, rY + 6, 'Rₒ', 'rgba(52,211,153,0.45)', 'center', 5.5);
      }

      // Column label below
      lbl(cx, L.colBot + 13, 'C' + i, isA ? 'rgba(78,205,196,0.65)' : 'rgba(255,255,255,0.12)', 'center', 7.5);
      // Routing weight
      if (isA) {
        const rw = [0.45, 0.30, 0.25][ACTIVE.indexOf(i)];
        lbl(cx, L.colBot + 25, 'R=' + rw.toFixed(2), 'rgba(255,107,53,0.4)', 'center', 6);
      }
    }

    // Column → Dendrite lines
    for (const i of ACTIVE) {
      conn(colX(i, L), L.colBot, colX(i, L), L.dendrite - 14, 'rgba(78,205,196,0.18)', 1);
    }

    // ═══════════ DENDRITIC READOUT ═══════════
    const smallH = 24;
    drawBar(barX, L.dendrite - smallH / 2, barW, smallH, 'rgba(52,211,153,0.07)', 'rgba(52,211,153,0.35)',
      '⑤ DENDRITIC READOUT  ·  basal ⊙ (1 + apical)', 'rgba(52,211,153,0.75)');
    conn(midX, L.dendrite + smallH / 2, midX, L.lateral - smallH / 2 - 2, 'rgba(255,255,255,0.08)', 1);

    // ═══════════ LATERAL PROPAGATION ═══════════
    drawBar(barX, L.lateral - smallH / 2, barW, smallH, 'rgba(99,102,241,0.07)', 'rgba(99,102,241,0.3)',
      'LATERAL CORTICAL PROPAGATION  ·  chunk-causal conv', 'rgba(99,102,241,0.65)');
    conn(midX, L.lateral + smallH / 2, midX, L.gain - barH / 2 - 2, 'rgba(255,255,255,0.08)', 1);

    // ═══════════ CT FEEDBACK (RIGHT SIDEBAR) ═══════════
    // Vertical line
    ctx.setLineDash([4, 4]);
    ctx.beginPath(); ctx.moveTo(fbX, L.lateral + smallH / 2);
    ctx.lineTo(fbX, L.router - routerH / 2);
    ctx.strokeStyle = 'rgba(251,146,60,0.25)'; ctx.lineWidth = 1.2; ctx.stroke();
    ctx.setLineDash([]);
    // Horizontal taps
    conn(barR, L.lateral, fbX, L.lateral + smallH / 2, 'rgba(251,146,60,0.12)', 0.8, [3, 3]);
    conn(fbX, L.router, barR, L.router, 'rgba(251,146,60,0.12)', 0.8, [3, 3]);
    // Label
    ctx.save();
    ctx.translate(fbX + 14, (L.lateral + L.router) / 2);
    ctx.rotate(-Math.PI / 2);
    lbl(0, 0, '⑥ CT FEEDBACK → R′', 'rgba(251,146,60,0.5)', 'center', 7);
    ctx.restore();

    // ═══════════ CEREBELLAR CORRECTOR (FAR RIGHT) ═══════════
    const cTopY = L.router + routerH;
    const cBotY = L.gain - barH / 2;
    // Vertical dashed
    ctx.setLineDash([3, 5]);
    ctx.beginPath(); ctx.moveTo(corrX, cTopY); ctx.lineTo(corrX, cBotY);
    ctx.strokeStyle = 'rgba(69,183,209,0.3)'; ctx.lineWidth = 1.3; ctx.stroke();
    ctx.setLineDash([]);
    // Box
    const bxH = 56;
    const bxY = (cTopY + cBotY) / 2 - bxH / 2;
    rr(corrX - 22, bxY, 44, bxH, 6);
    ctx.fillStyle = 'rgba(69,183,209,0.05)'; ctx.fill();
    ctx.strokeStyle = 'rgba(69,183,209,0.25)'; ctx.lineWidth = 0.8; ctx.stroke();
    lbl(corrX, bxY + 12, '⑦ FAST', 'rgba(69,183,209,0.55)', 'center', 6.5);
    lbl(corrX, bxY + 24, 'CORRECTOR', 'rgba(69,183,209,0.55)', 'center', 6);
    lbl(corrX, bxY + 38, 'Δ = VUᵀ', 'rgba(69,183,209,0.5)', 'center', 6);
    lbl(corrX, bxY + bxH + 10, 'rank-r', 'rgba(69,183,209,0.3)', 'center', 5.5);
    // Connection to gain bar
    conn(corrX, cBotY, barR - 20, L.gain, 'rgba(69,183,209,0.12)', 0.8, [3, 3]);

    // ═══════════ GLOBAL GAIN + RESIDUAL ═══════════
    drawBar(barX, L.gain - barH / 2, barW, barH, 'rgba(251,191,36,0.06)', 'rgba(251,191,36,0.3)',
      '⑧ GLOBAL GAIN  gᵍₐᵢₙ ⊙ Y  +  Δ  →  RESIDUAL + DROP', 'rgba(251,191,36,0.7)');
    conn(midX, L.gain + barH / 2, midX, L.ffn - barH / 2 - 2, 'rgba(255,255,255,0.08)', 1);

    // ═══════════ SwiGLU FFN ═══════════
    drawBar(barX, L.ffn - barH / 2, barW, barH, 'rgba(255,255,255,0.03)', 'rgba(255,255,255,0.18)',
      'RMSNorm → SwiGLU FFN → RESIDUAL + DROP', 'rgba(255,255,255,0.5)');
    conn(midX, L.ffn + barH / 2, midX, L.output - barH / 2 - 2, 'rgba(255,255,255,0.08)', 1);

    // ═══════════ OUTPUT ═══════════
    drawBar(barX, L.output - barH / 2, barW, barH, 'rgba(78,205,196,0.07)', 'rgba(78,205,196,0.3)',
      'X⁺ ∈ ℝᴮˣᵀˣᵈ  —  BLOCK OUTPUT', 'rgba(78,205,196,0.7)');

    // ═══════════ SKIP / RESIDUAL (LEFT) ═══════════
    ctx.setLineDash([2, 4]);
    ctx.beginPath();
    ctx.moveTo(skipX, L.norm + barH / 2);
    ctx.lineTo(skipX - 14, L.norm + barH / 2);
    ctx.lineTo(skipX - 14, L.gain);
    ctx.lineTo(skipX, L.gain);
    ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1; ctx.stroke();
    ctx.setLineDash([]);
    lbl(skipX - 24, (L.norm + L.gain) / 2, 'SKIP', 'rgba(255,255,255,0.12)', 'center', 5.5);

    // ═══════════ PARTICLES ═══════════
    memParticles.forEach(p => { p.update(); p.draw(L); });
    flowParticles.forEach(p => { p.update(); p.draw(L); });
    corrParticles.forEach(p => { p.update(); p.draw(L); });
    fbParticles.forEach(p => { p.update(); p.draw(L); });

    requestAnimationFrame(draw);
  }

  draw();

  window.toggleSpeed = function() {
    speedMult = speedMult === 1 ? 2 : speedMult === 2 ? 0.5 : 1;
    document.getElementById('btnSpeed').textContent = speedMult + '× Speed';
  };
  window.toggleLabels = function() {
    showLabels = !showLabels;
    document.getElementById('btnLabels').classList.toggle('active', showLabels);
  };
})();
</script>

</body>
</html>
